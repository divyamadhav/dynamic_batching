blocks = random_data$project,
p.adjust.method="BH")
print(CT)
}
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 2 BATCHBISECT', 'stagger 2 BATCHBISECT', 'stagger_mfu 2 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 2 BATCHSTOP4', 'stagger 2 BATCHSTOP4', 'stagger_mfu 2 BATCHSTOP4', 'random_exponential -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 2 BATCHDIVIDE4', 'stagger 2 BATCHDIVIDE4', 'stagger_mfu 2 BATCHDIVIDE4', 'random_random -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bs4_filters, bd4_filters)
for (lwd in best_lwds){
print(lwd)
eval_data <- new_dynamic %>% filter(final_methods %in% lwd)
print(length(eval_data$project))
res <- friedman.test(builds_saved ~ final_methods | project, data = eval_data)
print(res)
CT = frdAllPairsConoverTest(y      = eval_data$builds_saved,
groups = eval_data$final_methods,
blocks = eval_data$project,
p.adjust.method="BH")
print(CT)
}
final_filter <- list('linear 1 BATCHBISECT', 'exponential 3 BATCHSTOP4', 'exponential 3 BATCHDIVIDE4')
final_data <- new_dynamic %>% filter(final_methods %in% final_filter)
res <- friedman.test(builds_saved ~ final_methods | project, data = final_data)
print(res)
FT = xtabs(builds_saved ~ final_methods + project,
data = final_data)
KendallW(FT, correct=TRUE, test=TRUE)
CT = frdAllPairsConoverTest(y      = final_data$builds_saved,
groups = final_data$final_methods,
blocks = final_data$project,
p.adjust.method="BH")
print(CT)
# for (alg in algorithms) {
#
#   alg_data <- new_dynamic %>% filter(algorithm == alg)
#
#   res <- friedman.test(builds_saved ~ update_method_factor | project, data = alg_data)
#   print(res)
#
#   FT = xtabs(builds_saved ~ update_method_factor + project,
#              data = alg_data)
#
#   K <- KendallW(FT, correct=TRUE, test=TRUE)
#   print(K)
#
#   CT = frdAllPairsConoverTest(y      = alg_data$builds_saved,
#                               groups = alg_data$update_method_factor,
#                               blocks = alg_data$project,
#                               p.adjust.method="BH")
#   print(CT)
# }
library(dplyr)
library(effsize)
library(PMCMRplus)
library(DescTools)
library(FSA)
library(rstatix)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
new_dynamic <- build_data %>% filter((method == "new_dynamic") & (ci_skip == 0))
new_dynamic['update_method_factor'] <- paste(new_dynamic$update_method, new_dynamic$factor)
new_dynamic['final_methods'] <- paste(new_dynamic$update_method_factor, new_dynamic$algorithm)
new_dynamic <- new_dynamic[new_dynamic$update_method != 'half_exp', ]
algorithms <- list("BATCHBISECT", "BATCHSTOP4", "BATCHDIVIDE4")
final_methods <- unique(new_dynamic$final_methods)
update_methods <- unique(new_dynamic$update_method)
update_method_factor <- unique(new_dynamic$update_method_factor)
random_methods <- list("random_linear", "random_exponential", "random_random")
non_random <- update_methods[!(update_methods %in% random_methods)]
kruskal.test(builds_saved ~ final_methods, data = new_dynamic)
pairwise.wilcox.test(new_dynamic$builds_saved, new_dynamic$final_methods,p.adjust.method = "BH")
for (alg in algorithms) {
alg_data <- new_dynamic %>% filter(algorithm == alg)
for (m in non_random) {
print(alg)
print(m)
m_data <- alg_data %>% filter(update_method == m)
res <- friedman.test(builds_saved ~ final_methods | project, data = m_data)
print(res)
FT = xtabs(builds_saved ~ update_method_factor + project,
data = m_data)
K <- KendallW(FT, correct=TRUE, test=TRUE)
print(K)
CT = frdAllPairsConoverTest(y      = m_data$builds_saved,
groups = m_data$final_methods,
blocks = m_data$project,
p.adjust.method="BH")
print(CT)
}
print(alg)
print('random methods')
random_data <- alg_data %>% filter(update_method %in% random_methods)
res <- friedman.test(builds_saved ~ final_methods | project, data = random_data)
print(res)
FT = xtabs(builds_saved ~ update_method_factor + project,
data = random_data)
K <- KendallW(FT, correct=TRUE, test=TRUE)
print(K)
CT = frdAllPairsConoverTest(y      = random_data$builds_saved,
groups = random_data$final_methods,
blocks = random_data$project,
p.adjust.method="BH")
print(CT)
}
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 2 BATCHBISECT', 'stagger 2 BATCHBISECT', 'stagger_mfu 2 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 2 BATCHSTOP4', 'stagger 2 BATCHSTOP4', 'stagger_mfu 2 BATCHSTOP4', 'random_exponential -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 2 BATCHDIVIDE4', 'stagger 2 BATCHDIVIDE4', 'stagger_mfu 2 BATCHDIVIDE4', 'random_random -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bs4_filters, bd4_filters)
for (lwd in best_lwds){
print(lwd)
eval_data <- new_dynamic %>% filter(final_methods %in% lwd)
print(length(eval_data$project))
res <- friedman.test(builds_saved ~ final_methods | project, data = eval_data)
print(res)
CT = frdAllPairsConoverTest(y      = eval_data$builds_saved,
groups = eval_data$final_methods,
blocks = eval_data$project,
p.adjust.method="BH")
print(CT)
}
final_filter <- list('linear 1 BATCHBISECT', 'linear 4 BATCHSTOP4', 'exponential 2 BATCHDIVIDE4')
final_data <- new_dynamic %>% filter(final_methods %in% final_filter)
res <- friedman.test(builds_saved ~ final_methods | project, data = final_data)
print(res)
FT = xtabs(builds_saved ~ final_methods + project,
data = final_data)
KendallW(FT, correct=TRUE, test=TRUE)
CT = frdAllPairsConoverTest(y      = final_data$builds_saved,
groups = final_data$final_methods,
blocks = final_data$project,
p.adjust.method="BH")
print(CT)
# for (alg in algorithms) {
#
#   alg_data <- new_dynamic %>% filter(algorithm == alg)
#
#   res <- friedman.test(builds_saved ~ update_method_factor | project, data = alg_data)
#   print(res)
#
#   FT = xtabs(builds_saved ~ update_method_factor + project,
#              data = alg_data)
#
#   K <- KendallW(FT, correct=TRUE, test=TRUE)
#   print(K)
#
#   CT = frdAllPairsConoverTest(y      = alg_data$builds_saved,
#                               groups = alg_data$update_method_factor,
#                               blocks = alg_data$project,
#                               p.adjust.method="BH")
#   print(CT)
# }
library(dplyr)
library(effsize)
library(FSA)
library(PMCMRplus)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
new_dynamic <- build_data %>% filter((method == "new_dynamic") & (ci_skip == 0))
base_static <- build_data %>% filter((method == "baseline_static") & (ci_skip == 0))
new_dynamic <- new_dynamic[new_dynamic$update_method != 'half_exp', ]
new_dynamic['update_method_factor'] <- paste(new_dynamic$update_method, new_dynamic$factor)
new_dynamic['final_methods'] <- paste(new_dynamic$update_method_factor, new_dynamic$algorithm)
base_static['final_methods'] <- paste(base_static$algorithm, base_static$batch_size)
base_static['update_method_factor'] <- base_static$batch_size
algorithms <- list("BATCHBISECT", "BATCHSTOP4", "BATCHDIVIDE4")
final_methods <- unique(new_dynamic$final_methods)
update_methods <- unique(new_dynamic$update_method)
update_method_factor <- unique(new_dynamic$update_method_factor)
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 2 BATCHBISECT', 'stagger 2 BATCHBISECT', 'stagger_mfu 2 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 2 BATCHSTOP4', 'stagger 2 BATCHSTOP4', 'stagger_mfu 2 BATCHSTOP4', 'random_exponential -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 2 BATCHDIVIDE4', 'stagger 2 BATCHDIVIDE4', 'stagger_mfu 2 BATCHDIVIDE4', 'random_random -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bs4_filters, bd4_filters)
pdata = matrix(ncol=11, nrow=7)
random_methods <- list("random_linear", "random_exponential", "random_random")
non_random <- update_methods[!(update_methods %in% random_methods)]
list_range <- 1:3
for (i in list_range) {
alg <- algorithms[i]
f <- best_lwds[[i]]
alg_data <- new_dynamic %>% filter(algorithm == alg)
m_data <- alg_data %>% filter(final_methods %in% f)
base_alg <- base_static %>% filter(algorithm == alg)
print(alg)
eval_data <- rbind(base_alg, m_data)
res <- friedman.test(builds_saved ~ final_methods | project, data = eval_data)
print(res)
FT = xtabs(builds_saved ~ final_methods + project,
data = eval_data)
res = KendallW(FT, correct=TRUE, test=TRUE)
print(res)
CT = frdAllPairsConoverTest(y      = eval_data$builds_saved,
groups = eval_data$final_methods,
blocks = eval_data$project,
p.adjust.method="bonferroni")
print(CT)
}
#Comparing with Random Methods
bb_r = 'random_random -1 BATCHBISECT'
bs4_r = 'random_linear -1 BATCHSTOP4'
bd4_r = 'random_exponential -1 BATCHDIVIDE4'
best_randoms <- list(bb_r, bs4_r, bd4_r)
list_range <- 1:3
for (i in list_range) {
alg <- algorithms[i]
f <- best_randoms[[i]]
alg_data <- new_dynamic %>% filter(algorithm == alg)
m_data <- alg_data %>% filter(final_methods %in% f)
base_alg <- base_static %>% filter(algorithm == alg)
print(alg)
eval_data <- rbind(base_alg, m_data)
res <- friedman.test(builds_saved ~ final_methods | project, data = eval_data)
print(res)
FT = xtabs(builds_saved ~ final_methods + project,
data = eval_data)
res = KendallW(FT, correct=TRUE, test=TRUE)
print(res)
CT = frdAllPairsConoverTest(y      = eval_data$builds_saved,
groups = eval_data$final_methods,
blocks = eval_data$project,
p.adjust.method="bonferroni")
print(CT)
}
library(dplyr)
library(effsize)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
new_dynamic <- build_data %>% filter(method == "new_dynamic")
baseline_dynamic <- build_data %>% filter((method == "baseline_dynamic") & (ci_skip == 0))
baseline_static <- build_data %>% filter((method == "baseline_static") & (ci_skip == 0))
group_by(build_data, update_method) %>%
summarise(
count = n(),
mean = mean(builds_saved, na.rm = TRUE),
sd = sd(builds_saved, na.rm = TRUE),
median = median(builds_saved, na.rm = TRUE),
IQR = IQR(builds_saved, na.rm = TRUE)
)
new_dynamic['update_method_factor'] <- paste(new_dynamic$update_method, new_dynamic$factor)
new_dynamic['final_methods'] <- paste(new_dynamic$update_method_factor, new_dynamic$algorithm)
algorithms <- list("BATCHBISECT", "BATCHDIVIDE4", "BATCHSTOP4")
methods <- unique(new_dynamic$final_methods)
# kruskal.test(builds_saved ~ final_methods, data = new_dynamic)
# pairwise.wilcox.test(new_dynamic$builds_saved, new_dynamic$final_methods,p.adjust.method = "BH")
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 3 BATCHBISECT', 'stagger 3 BATCHBISECT', 'stagger_mfu 3 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 3 BATCHSTOP4', 'stagger 3 BATCHSTOP4', 'stagger_mfu 3 BATCHSTOP4', 'random_linear -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 3 BATCHDIVIDE4', 'stagger 3 BATCHDIVIDE4', 'stagger_mfu 3 BATCHDIVIDE4', 'random_exponential -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bd4_filters, bs4_filters)
for (i in 1:3) {
alg <- algorithms[i]
print('Beginning new algorithm')
alg_data <- new_dynamic %>% filter(algorithm == alg)
filters <- best_lwds[[i]]
baseline_alg <- baseline_dynamic %>% filter(algorithm == alg)
batch_sizes <- unique(baseline_alg$batch_size)
for (m in filters) {
cat("method", m)
m_data <- alg_data %>% filter(final_methods == m)
print(length(m_data$project))
w_skip <- m_data %>% filter( ci_skip == 1)
wo_skip <- m_data %>% filter( ci_skip == 0)
print(length(baseline_alg$project))
print(length(w_skip$project))
print(length(wo_skip$project))
# cat(m, "with ci_skip ", alg)
# res <- wilcox.test(w_skip$builds_saved, baseline_alg$builds_saved, paired=TRUE)
# print(res)
# res <- cliff.delta(wo_skip$builds_saved, baseline_alg$builds_saved,return.dm=TRUE)
# print(res)
cat(m, "without ci_skip")
res <- wilcox.test(wo_skip$builds_saved, baseline_alg$builds_saved, paired=TRUE)
print(res)
res <- cliff.delta(wo_skip$builds_saved, baseline_alg$builds_saved,return.dm=TRUE)
print(res)
}
}
library(dplyr)
library(effsize)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
new_dynamic <- build_data %>% filter(method == "new_dynamic")
baseline_dynamic <- build_data %>% filter((method == "baseline_dynamic") & (ci_skip == 0))
baseline_static <- build_data %>% filter((method == "baseline_static") & (ci_skip == 0))
group_by(build_data, update_method) %>%
summarise(
count = n(),
mean = mean(builds_saved, na.rm = TRUE),
sd = sd(builds_saved, na.rm = TRUE),
median = median(builds_saved, na.rm = TRUE),
IQR = IQR(builds_saved, na.rm = TRUE)
)
new_dynamic['update_method_factor'] <- paste(new_dynamic$update_method, new_dynamic$factor)
new_dynamic['final_methods'] <- paste(new_dynamic$update_method_factor, new_dynamic$algorithm)
algorithms <- list("BATCHBISECT", "BATCHDIVIDE4", "BATCHSTOP4")
methods <- unique(new_dynamic$final_methods)
# kruskal.test(builds_saved ~ final_methods, data = new_dynamic)
# pairwise.wilcox.test(new_dynamic$builds_saved, new_dynamic$final_methods,p.adjust.method = "BH")
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 2 BATCHBISECT', 'stagger 2 BATCHBISECT', 'stagger_mfu 2 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 2 BATCHSTOP4', 'stagger 2 BATCHSTOP4', 'stagger_mfu 2 BATCHSTOP4', 'random_exponential -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 2 BATCHDIVIDE4', 'stagger 2 BATCHDIVIDE4', 'stagger_mfu 2 BATCHDIVIDE4', 'random_random -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bd4_filters, bs4_filters)
for (i in 1:3) {
alg <- algorithms[i]
print('Beginning new algorithm')
alg_data <- new_dynamic %>% filter(algorithm == alg)
filters <- best_lwds[[i]]
baseline_alg <- baseline_dynamic %>% filter(algorithm == alg)
batch_sizes <- unique(baseline_alg$batch_size)
for (m in filters) {
cat("method", m)
m_data <- alg_data %>% filter(final_methods == m)
print(length(m_data$project))
w_skip <- m_data %>% filter( ci_skip == 1)
wo_skip <- m_data %>% filter( ci_skip == 0)
print(length(baseline_alg$project))
print(length(w_skip$project))
print(length(wo_skip$project))
# cat(m, "with ci_skip ", alg)
# res <- wilcox.test(w_skip$builds_saved, baseline_alg$builds_saved, paired=TRUE)
# print(res)
# res <- cliff.delta(wo_skip$builds_saved, baseline_alg$builds_saved,return.dm=TRUE)
# print(res)
cat(m, "without ci_skip")
res <- wilcox.test(wo_skip$builds_saved, baseline_alg$builds_saved, paired=TRUE)
print(res)
res <- cliff.delta(wo_skip$builds_saved, baseline_alg$builds_saved,return.dm=TRUE)
print(res)
}
}
library(dplyr)
library(effsize)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
new_dynamic <- build_data %>% filter(method == "new_dynamic")
baseline_dynamic <- build_data %>% filter((method == "baseline_dynamic") & (ci_skip == 0))
baseline_static <- build_data %>% filter((method == "baseline_static") & (ci_skip == 0))
group_by(build_data, update_method) %>%
summarise(
count = n(),
mean = mean(builds_saved, na.rm = TRUE),
sd = sd(builds_saved, na.rm = TRUE),
median = median(builds_saved, na.rm = TRUE),
IQR = IQR(builds_saved, na.rm = TRUE)
)
new_dynamic['update_method_factor'] <- paste(new_dynamic$update_method, new_dynamic$factor)
new_dynamic['final_methods'] <- paste(new_dynamic$update_method_factor, new_dynamic$algorithm)
algorithms <- list("BATCHBISECT", "BATCHDIVIDE4", "BATCHSTOP4")
methods <- unique(new_dynamic$final_methods)
# kruskal.test(builds_saved ~ final_methods, data = new_dynamic)
# pairwise.wilcox.test(new_dynamic$builds_saved, new_dynamic$final_methods,p.adjust.method = "BH")
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 2 BATCHBISECT', 'stagger 2 BATCHBISECT', 'stagger_mfu 2 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 2 BATCHSTOP4', 'stagger 2 BATCHSTOP4', 'stagger_mfu 2 BATCHSTOP4', 'random_exponential -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 2 BATCHDIVIDE4', 'stagger 2 BATCHDIVIDE4', 'stagger_mfu 2 BATCHDIVIDE4', 'random_random -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bd4_filters, bs4_filters)
for (i in 1:3) {
alg <- algorithms[i]
print('Beginning new algorithm')
alg_data <- new_dynamic %>% filter(algorithm == alg)
filters <- best_lwds[[i]]
baseline_alg <- baseline_dynamic %>% filter(algorithm == alg)
batch_sizes <- unique(baseline_alg$batch_size)
for (m in filters) {
cat("method", m)
m_data <- alg_data %>% filter(final_methods == m)
print(length(m_data$project))
w_skip <- m_data %>% filter( ci_skip == 1)
wo_skip <- m_data %>% filter( ci_skip == 0)
print(length(baseline_alg$project))
print(length(w_skip$project))
print(length(wo_skip$project))
# cat(m, "with ci_skip ", alg)
# res <- wilcox.test(w_skip$builds_saved, baseline_alg$builds_saved, paired=TRUE)
# print(res)
# res <- cliff.delta(wo_skip$builds_saved, baseline_alg$builds_saved,return.dm=TRUE)
# print(res)
cat(m, "without ci_skip")
res <- wilcox.test(wo_skip$builds_saved, baseline_alg$builds_saved, paired=TRUE)
print(res)
res <- cliff.delta(wo_skip$builds_saved, baseline_alg$builds_saved,return.dm=TRUE)
print(res)
}
}
library(dplyr)
library(effsize)
library(FSA)
library(PMCMRplus)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
new_dynamic <- build_data %>% filter((method == "new_dynamic") & (ci_skip == 0))
base_static <- build_data %>% filter((method == "baseline_static") & (ci_skip == 0))
new_dynamic <- new_dynamic[new_dynamic$update_method != 'half_exp', ]
new_dynamic['update_method_factor'] <- paste(new_dynamic$update_method, new_dynamic$factor)
new_dynamic['final_methods'] <- paste(new_dynamic$update_method_factor, new_dynamic$algorithm)
base_static['final_methods'] <- paste(base_static$algorithm, base_static$batch_size)
base_static['update_method_factor'] <- base_static$batch_size
algorithms <- list("BATCHBISECT", "BATCHSTOP4", "BATCHDIVIDE4")
final_methods <- unique(new_dynamic$final_methods)
update_methods <- unique(new_dynamic$update_method)
update_method_factor <- unique(new_dynamic$update_method_factor)
bb_filters <- list('linear 1 BATCHBISECT', 'exponential 2 BATCHBISECT', 'stagger 2 BATCHBISECT', 'stagger_mfu 2 BATCHBISECT', 'random_random -1 BATCHBISECT')
bs4_filters <- list('linear 4 BATCHSTOP4', 'exponential 2 BATCHSTOP4', 'stagger 2 BATCHSTOP4', 'stagger_mfu 2 BATCHSTOP4', 'random_exponential -1 BATCHSTOP4')
bd4_filters <- list('linear 1 BATCHDIVIDE4', 'exponential 2 BATCHDIVIDE4', 'stagger 2 BATCHDIVIDE4', 'stagger_mfu 2 BATCHDIVIDE4', 'random_random -1 BATCHDIVIDE4')
best_lwds <- list(bb_filters, bs4_filters, bd4_filters)
pdata = matrix(ncol=11, nrow=7)
random_methods <- list("random_linear", "random_exponential", "random_random")
non_random <- update_methods[!(update_methods %in% random_methods)]
list_range <- 1:3
for (i in list_range) {
alg <- algorithms[i]
f <- best_lwds[[i]]
alg_data <- new_dynamic %>% filter(algorithm == alg)
m_data <- alg_data %>% filter(final_methods %in% f)
base_alg <- base_static %>% filter(algorithm == alg)
print(alg)
eval_data <- rbind(base_alg, m_data)
res <- friedman.test(builds_saved ~ final_methods | project, data = eval_data)
print(res)
FT = xtabs(builds_saved ~ final_methods + project,
data = eval_data)
res = KendallW(FT, correct=TRUE, test=TRUE)
print(res)
CT = frdAllPairsConoverTest(y      = eval_data$builds_saved,
groups = eval_data$final_methods,
blocks = eval_data$project,
p.adjust.method="bonferroni")
print(CT)
}
#Comparing with Random Methods
bb_r = 'random_random -1 BATCHBISECT'
bs4_r = 'random_linear -1 BATCHSTOP4'
bd4_r = 'random_exponential -1 BATCHDIVIDE4'
best_randoms <- list(bb_r, bs4_r, bd4_r)
list_range <- 1:3
for (i in list_range) {
alg <- algorithms[i]
f <- best_randoms[[i]]
alg_data <- new_dynamic %>% filter(algorithm == alg)
m_data <- alg_data %>% filter(final_methods %in% f)
base_alg <- base_static %>% filter(algorithm == alg)
print(alg)
eval_data <- rbind(base_alg, m_data)
res <- friedman.test(builds_saved ~ final_methods | project, data = eval_data)
print(res)
FT = xtabs(builds_saved ~ final_methods + project,
data = eval_data)
res = KendallW(FT, correct=TRUE, test=TRUE)
print(res)
CT = frdAllPairsConoverTest(y      = eval_data$builds_saved,
groups = eval_data$final_methods,
blocks = eval_data$project,
p.adjust.method="bonferroni")
print(CT)
}
library(dplyr)
library(effsize)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
static_batching <- build_data %>% filter(method == "baseline_static")
baseline_dynamic <- build_data %>% filter(method == "baseline_dynamic")
timeout_rule <- build_data %>% filter(method == "timeout_rule")
new_dynamic <- build_data %>% filter(method == "new_dynamic")
static_batching['final_methods'] <- paste(static_batching$algorithm, static_batching$batch_size)
algorithms <- list("BATCHBISECT", "BATCHSTOP4", "BATCHDIVIDE4")
final_methods <- unique(static_batching$final_methods)
for (m in final_methods) {
s_alg <- static_batching %>% filter(final_methods == m)
#d_alg <- baseline_dynamic %>% filter(final_methods == m)
print(m)
w_skip <- s_alg %>% filter(ci_skip == 1)
wo_skip <- s_alg %>% filter(ci_skip == 0)
N <- length(w_skip) + length(wo_skip)
res <- wilcox.test(w_skip$builds_saved, wo_skip$builds_saved, p.adjust.method = "BH")
print(res)
res <- cliff.delta(w_skip$builds_saved, wo_skip$builds_saved,return.dm=TRUE)
print(res)
}
for (alg in algorithms) {
print(alg)
d_alg <- baseline_dynamic %>% filter(algorithm == alg)
w_skip <- d_alg %>% filter(ci_skip == 1)
wo_skip <- d_alg %>% filter(ci_skip == 0)
N <- length(w_skip) + length(wo_skip)
res <- wilcox.test(w_skip$builds_saved, wo_skip$builds_saved, p.adjust.method = "BH")
print(res)
res <- cliff.delta(w_skip$builds_saved, wo_skip$builds_saved,return.dm=TRUE)
print(res)
}
library(dplyr)
library(effsize)
build_data <- read.csv('/Users/divyakamath/Documents/Submitted Papers/EMSE - LWD/icsme/rebuttal/ci_skip_all_results.csv')
static_batching <- build_data %>% filter(method == "baseline_static")
baseline_dynamic <- build_data %>% filter(method == "baseline_dynamic")
timeout_rule <- build_data %>% filter(method == "timeout_rule")
new_dynamic <- build_data %>% filter(method == "new_dynamic")
static_batching['final_methods'] <- paste(static_batching$algorithm, static_batching$batch_size)
algorithms <- list("BATCHBISECT", "BATCHSTOP4", "BATCHDIVIDE4")
final_methods <- unique(static_batching$final_methods)
for (m in final_methods) {
s_alg <- static_batching %>% filter(final_methods == m)
#d_alg <- baseline_dynamic %>% filter(final_methods == m)
print(m)
w_skip <- s_alg %>% filter(ci_skip == 1)
wo_skip <- s_alg %>% filter(ci_skip == 0)
N <- length(w_skip) + length(wo_skip)
res <- wilcox.test(w_skip$builds_saved, wo_skip$builds_saved, p.adjust.method = "BH")
print(res)
res <- cliff.delta(w_skip$builds_saved, wo_skip$builds_saved,return.dm=TRUE)
print(res)
}
for (alg in algorithms) {
print(alg)
d_alg <- baseline_dynamic %>% filter(algorithm == alg)
w_skip <- d_alg %>% filter(ci_skip == 1)
wo_skip <- d_alg %>% filter(ci_skip == 0)
N <- length(w_skip) + length(wo_skip)
res <- wilcox.test(w_skip$builds_saved, wo_skip$builds_saved, p.adjust.method = "BH")
print(res)
res <- cliff.delta(w_skip$builds_saved, wo_skip$builds_saved,return.dm=TRUE)
print(res)
}
